<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>지시 변수를 이렇게도 저렇게도 – 사무엘의 수리 언어 블로그</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-09537c9ecba8558085948e1b802a414a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">사무엘의 수리 언어 블로그</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">홈</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">소개</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/samuel4388"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/sam458755"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">지시 변수를 이렇게도 저렇게도</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">mathematics</div>
                <div class="quarto-category">probability</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 6월 19일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><em>A First Course in Probability</em>, 9th edition by Sheldon Ross<br>
Chapter 7, Problem 7.63., p.357</p>
<p>확률 문제를 풀면 지시 변수(indicator variable)와 친해지게 된다. 재밌는 점은, 지시 변수 설정하는 방법이 한 가지만 있는 게 아니라는 것이다. 지시 변수라는 개념 자체는 간단하다. 사건이 발생하면 1이고, 사건이 발생하지 않으면 0인 변수이다. 그래서 지시 변수의 기댓값은 지시 변수가 1일 확률과 동일하다. 마치 컴퓨터의 비트와 같은 지시 변수는 잘만 활용하면 문제 풀이를 정말 용이하게 해 준다. 나는 이걸 로스 확률론 7장 63번 문제의 (a)를 풀면서 느꼈다.</p>
<hr>
<p><strong>7.63.</strong> 어떤 항아리에 공이 총 30개 들어 있는데, 그 중 10개는 빨간색이고 8개는 파란색이다. 이 항아리에서 무작위로 12개의 공을 꺼낸다. 빨간 공의 개수를 <span class="math inline">\(X\)</span>, 파란 공의 개수를 <span class="math inline">\(Y\)</span>라고 하자.</p>
<p>(a) 적절한 지시 변수(즉, 베르누이 확률 변수)를 정의함으로써 <span class="math inline">\(\mathrm{Cov}(X, Y)\)</span>를 구하라. <span class="math display">\[
X_i, Y_j \text{ such that } X = \sum_{i=1}^{10} X_i, \; Y = \sum_{j=1}^{8} Y_j
\]</span></p>
<hr>
<p>먼저 교재에 나온 지시 변수를 이용해서 (a)를 구해 보자. 여기서 <span class="math inline">\(X_i\)</span>는 빨간 공들에 1부터 8까지 순서를 매긴 뒤에, 순서 매긴 공이 뽑혔을 때 1이 되는 지시 변수이다. 그러니까 예를 들어 <span class="math inline">\(X_3 = 1\)</span>은 세 번째 빨간 공이 뽑혔다는 얘기다. 그러면 이 지시 변수들의 합인 <span class="math inline">\(X\)</span>는 뽑힌 빨간 공의 개수가 된다. <span class="math inline">\(Y\)</span>에도 마찬가지의 논리가 적용된다.</p>
<p>그러면 공분산을 어떻게 구할 수 있을까? 공분산의 이중 선형성을 이용하면 다음과 같이 쓸 수 있다: <span class="math display">\[
\text{Cov}\left(X, Y\right) = \text{Cov}\left(\sum_{i=1}^{10} X_i, \sum_{j=1}^{8} Y_j\right) = \sum_{i=1}^{10} \sum_{j=1}^{8} \text{Cov}\left(X_i, Y_j\right)
\]</span></p>
<p>그러면 이제 <span class="math inline">\(\mathrm{Cov}(X_i, Y_j)\)</span>를 구하면 되는데, 이는 공분산의 정의에 따라 다음과 같이 쓸 수 있다:</p>
<p><span class="math display">\[
\text{Cov}(X_i, Y_j) = E[X_i Y_j] - E[X_i] E[Y_j]
\]</span></p>
<p><span class="math inline">\(E[X_i]\)</span>를 구하는 건 쉽다. <span class="math inline">\(30\)</span>개의 공들 중에서 <span class="math inline">\(12\)</span>개를 뽑는 상황이니까 전체 경우의 수는 <span class="math inline">\(\binom{30}{12}\)</span>가 된다. 그런데 <span class="math inline">\(i\)</span>번째 빨간 공을 구하는 경우의 수는 이미 하나를 뽑은 상황에서 나머지 <span class="math inline">\(11\)</span>개의 공을 뽑는 거니까 <span class="math inline">\(\binom{29}{11}\)</span>이 된다. <span class="math inline">\(E[Y_i]\)</span>에도 같은 논리가 적용돼서 <span class="math display">\[
E[X_i] = E[Y_j] = \frac{\binom{29}{11}}{\binom{30}{12}} = \frac{\frac{29!}{18!11!}}{\frac{30!}{18!12!}} = \frac{12}{30} = \frac{2}{5}
\]</span></p>
<p>라고 쓸 수 있다.</p>
<p>그러면 <span class="math inline">\(E[X_iY_j]\)</span>는 어떻게 구할 수 있을까? 이번에도 비슷한 논리가 적용된다. 전체 경우의 수는 같고, 이번에는 두 개가 고정된 거니까 나머지 28개의 공들 중에서 10개를 뽑으면 된다. 그러면 <span class="math display">\[
E[X_i Y_j] = \frac{\binom{28}{10}}{\binom{30}{12}} = \frac{\frac{28!}{18!10!}}{\frac{30!}{18!12!}} = \frac{11 \cdot 12}{29 \cdot 30} = \frac{22}{145}
\]</span></p>
<p>따라서 <span class="math display">\[
\text{Cov}(X_i, Y_j) = E[X_i Y_j] - E[X_i] E[Y_j] = \frac{22}{145} - \left(\frac{2}{5}\right)^2 = -\frac{6}{725}
\]</span> <span class="math display">\[
\text{Cov}(X, Y) = 10 \cdot 8 \cdot \left(-\frac{6}{725}\right) = -\frac{96}{145}
\]</span></p>
<p>이렇게 구할 수 있다.</p>
<hr>
<p>그런데 나는 사실 맨 처음에 이 문제를 접했을 때 책에 나온 지시 함수를 쓰지 않았다. 책에 나온 지시 함수로 푸는 게 조금 더 간단하긴 하지만, 나는 다른 방식으로 문제를 접근했다. 이번에는 <span class="math inline">\(i\)</span>번째로 뽑은 공이 빨강이면 1인 지시 함수 <span class="math inline">\(X_i\)</span>, j번째로 뽑은 공이 파랑이면 <span class="math inline">\(1\)</span>인 지시 함수 <span class="math inline">\(Y_j\)</span>를 생각해 보자: <span class="math display">\[
X_i = \begin{cases}
1, &amp; \text{if the i-th ball is red} \\
0, &amp; \text{otherwise}
\end{cases}, \quad
Y_j = \begin{cases}
1, &amp; \text{if the j-th ball is blue} \\
0, &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>그리고 <span class="math inline">\(X = \sum_{i=1}^{12} X_i\)</span>, <span class="math inline">\(Y = \sum_{j=1}^{12} Y_j\)</span>라고 둬 보자. 그러면 이번에는 공분산이 다음과 같이 나온다: <span class="math display">\[
\text{Cov}(X, Y) = \text{Cov}\left(\sum_{i=1}^{12} X_i, \sum_{j=1}^{12} Y_j\right) = \sum_{i=1}^{12} \sum_{j=1}^{12} \text{Cov}(X_i, Y_j)
\]</span></p>
<p>이번에는 이를 <span class="math inline">\(i\)</span>와 <span class="math inline">\(j\)</span>가 같은 경우와 다른 경우로 분리해야 한다. 왜 그럴까? 예를 들어, 다섯 번째로 뽑은 공은 빨간 공이거나 파란 공이거나 둘 다 아닐 수는 있지만, 동시에 빨갛고 파랄 수는 없기 때문이다. 그래서 이 둘을 다르게 취급해야 한다. 따라서 <span class="math display">\[
\text{Cov}(X, Y) = \sum_{i=1}^{12} \text{Cov}(X_i, Y_i) + \sum_{i \neq j} \text{Cov}(X_i, Y_j)
\]</span></p>
<p>이렇게 쓸 수 있다.</p>
<p>앞서 뽑은 공들에 대한 정보가 없다는 가정 하에, 몇 번째에 뽑건 <span class="math inline">\(i\)</span>번째에 뽑은 공이 파란 공일 확률은 <span class="math inline">\(E[X_i] = \frac{10}{30} = \frac{1}{3}\)</span>이다. 마찬가지로 <span class="math inline">\(j\)</span>번째에 뽑은 공이 빨간 공일 확률은 <span class="math inline">\(E[Y_j] = \frac{8}{30} = \frac{4}{15}\)</span>이다. <span class="math inline">\(i = j\)</span>인 경우에는 <span class="math inline">\(E[X_iY_j] = E[X_iY_i]\)</span>가 <span class="math inline">\(0\)</span>이 될 수밖에 없다. 왜냐하면 지시 함수의 특성상 <span class="math inline">\(E[X_iY_i] = P\{X_iY_i = 1\}\)</span>이어야 하는데, 앞서 말했듯이 뽑은 공이 동시에 빨갛고 파랄 수 없기 때문이다. 따라서 <span class="math inline">\(i = j\)</span>인 경우 <span class="math display">\[
\text{Cov}(X_i, Y_i) = E[X_i Y_i] - E[X_i] E[Y_i] = 0 - \frac{1}{3} \cdot \frac{4}{15} = -\frac{4}{45}
\]</span></p>
<p>가 된다.</p>
<p><span class="math inline">\(i ≠ j\)</span>인 경우에는 어떻게 될까? <span class="math inline">\(E[X_i]\)</span>와 <span class="math inline">\(E[Y_j]\)</span>는 같고, <span class="math inline">\(E[X_iY_j]\)</span>만 다르게 설정하면 된다. <span class="math inline">\(E[X_iY_j] = P\{X_iY_j = 1\}\)</span>이니까, <span class="math inline">\(X_i\)</span>와 <span class="math inline">\(Y_j\)</span>가 둘 다 1이 되는 상황을 생각해 보면 된다.</p>
<p>먼저 <span class="math inline">\(i &lt; j\)</span>인 경우를 생각해 보자. <span class="math inline">\(i\)</span>번째 뽑기에서 빨간 공이 뽑힐 확률은 <span class="math inline">\(\frac{10}{30} = \frac{1}{3}\)</span>이다. <span class="math inline">\(j\)</span>번째 뽑기에서 파란 공이 뽑힐 확률은 빨간 공이 이미 하나 뽑혔으니까 <span class="math inline">\(\frac{8}{30 - 1} = \frac{8}{29}\)</span>이다. 따라서 <span class="math inline">\(E[X_iY_j] = \frac{1}{3} \cdot \frac{8}{29} = \frac{8}{87}\)</span>이 된다.</p>
<p>다음으로 <span class="math inline">\(i &gt; j\)</span>인 경우를 생각해 보자. <span class="math inline">\(j\)</span>번째 뽑기에서 파란 공이 뽑힐 확률은 <span class="math inline">\(\frac{8}{30} = \frac{4}{15}\)</span>이다. <span class="math inline">\(i\)</span>번째 뽑기에서 빨간 공이 뽑힐 확률은 파란 공이 이미 하나 뽑혔으니까 <span class="math inline">\(\frac{10}{30 - 1} = \frac{10}{29}\)</span>이다. 따라서 <span class="math inline">\(E[X_iY_j] = \frac{4}{15} \cdot \frac{10}{29} = \frac{40}{435} = \frac{8}{87}\)</span>이 된다.</p>
<p>즉, <span class="math inline">\(i &lt; j\)</span>이건 <span class="math inline">\(i &gt; j\)</span>이건 <span class="math inline">\(E[X_iY_j]\)</span>는 동일하다는 점을 알 수 있다. 이는 순서와 상관 없이, 빨간 공 하나, 파란 공 하나가 뽑혔다는 사실에는 변함이 없기 때문이라고 받아들일 수 있겠다.</p>
<p>따라서 <span class="math inline">\(i ≠ j\)</span>인 경우 <span class="math display">\[
\text{Cov}(X_i, Y_j) = E[X_i Y_j] - E[X_i] E[Y_j] = \frac{8}{87} - \frac{1}{3} \cdot \frac{4}{15} = \frac{8}{87} - \frac{4}{45} = \frac{4}{1305} \quad (i ≠ j)
\]</span></p>
<p>와 같이 구할 수 있다.</p>
<p><span class="math inline">\(i = j\)</span>인 경우는 12가지 경우가 있고, <span class="math inline">\(i ≠ j\)</span>인 경우는 <span class="math inline">\(\binom{12}{2} \cdot 2!\)</span>가지 경우가 있으므로</p>
<p><span class="math display">\[
\begin{align}
\text{Cov}(X, Y) &amp;= \sum_{i=1}^{12} \text{Cov}(X_i, Y_i) + \sum_{i \neq j} \text{Cov}(X_i, Y_j) \\
&amp;= 12 \cdot \left(-\frac{4}{45}\right) + \binom{12}{2} \cdot 2! \cdot \frac{4}{1305} = -\frac{96}{145}
\end{align}
\]</span></p>
<p>이와 같이 같은 결과가 나온다.</p>




</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>